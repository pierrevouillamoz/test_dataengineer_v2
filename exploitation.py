import pandas as pd
import datetime as dt
import matplotlib.pyplot as plt
import geopandas as gpd

##fonctions du projet

#Toutes les fonctions du projet vont s'appliquer sur le dataframe Arretes_Zones_alerte
#qui va subir des modifications succesives.
#En fait à la fin de chaque utilisation, il suffit de supprimer Arretes_Zones_alerte pour optimiser
#la mémoire et de recréer ce dataframe via Arretes_Zones_alerte=data.

#filtration

def filtrage_par_date(Arretes_Zones_alerte,date):  

    """
    Cette fonction sert à récupérer la liste des arrêtés en cours à une date déterminée.
    
    """
    
    date=pd.to_datetime(date, infer_datetime_format=True)
    
    Arretes_Zones_alerte=Arretes_Zones_alerte[(Arretes_Zones_alerte["debut_validite_arrete"]<=date)&(Arretes_Zones_alerte["fin_validite_arrete"]>date)]

    return Arretes_Zones_alerte


def filtrage_par_type_eau(Arretes_Zones_alerte,type="SUP"):   

    """
    Cette fonction sert à filtrer le dataframe principal entre les eaux de type
    superficiel et souterraine
    """
       
    if (type=="SUP") or (type=="SOU"):
        Arretes_Zones_alerte=Arretes_Zones_alerte[Arretes_Zones_alerte["type_zone"]==type]
        return Arretes_Zones_alerte
    else:
        pass


#Aggregation


def agregation_par_arrete(Arretes_Zones_alerte):


    """
    Cette fonction permet d'aggréger les données à l'échelle des arrêtés.
    Un arrêté contient plusieurs zones d'application (unité hydrologique cohérente).
    L'aggrégation somme la surface des zones concernées et nous perdons l'information
    sur le caractère superficiel ou souterrain des eaux.
    Je fais l'hypothèse, partiellement vérifié, que les dates de l'arrêté concerne toutes les zones,
    ainsi je prends les dates moyennes pour le début et la fin de validité de l'arrêté.
    """
        
    Arretes_Zones_alerte=Arretes_Zones_alerte.groupby("id_arrete").agg({"surface_zone":"sum", 
                                  "surface_departement":"mean", 
                                  "debut_validite_arrete":"mean",
                                  "fin_validite_arrete":"mean",
                                  "duree (jours)":"mean"})  
   
    return Arretes_Zones_alerte


def agregation_par_niveau_alerte(Arretes_Zones_alerte):  


    """
    Cette fonction permet d'agréger les données à l'échelle des départements.
    J'ai eu des difficultés dans mon code car en sortie de l'application de méthode "value_counts()",
    il y avait un multi-index de créé.
    J'ai dû réinitialiser l'index pour sortir de la situation puis réaffecter un index.

    """
    
    #Aggregation par département en ne gardant que le niveau d'alerte de la zone qui connait le niveau le plus important
    Arretes_Zones_alerte=Arretes_Zones_alerte.groupby("code_departement").agg({"numero_niveau":max})

    #Dénombrement des départements par niveau d'alerte. 
    Arretes_Zones_alerte=Arretes_Zones_alerte["numero_niveau"].value_counts()
   
    Arretes_Zones_alerte=Arretes_Zones_alerte.reset_index()
    
    #Remplacement des codes des niveaux d'alerte par leur nom
    Arretes_Zones_alerte["niveau_alerte"]=Arretes_Zones_alerte["index"].replace([0,1,3,4,5],['0 - Aucun','1 - Vigilance','2 - Alerte','3 - Alerte renforcée','4 - Crise'])

    #Attribution d'un index
    Arretes_Zones_alerte=Arretes_Zones_alerte.set_index("niveau_alerte")
    
    Arretes_Zones_alerte=Arretes_Zones_alerte.rename(columns={"numero_niveau":"Nombre de département"})

    return Arretes_Zones_alerte["Nombre de département"].sort_index()


#Graphiques

def afficher_graph_bar(Arretes_Zones_alerte,title=""):

    """
    Cette fonction va afficher le diagramme du nombre de départements par zone d'alerte à une date donnée.
    Elle s'applique après une filtration par date et une aggrégation par niveau d'alerte.
    """
    

    fig, ax = plt.subplots(figsize=(6,6))
    plt.bar(Arretes_Zones_alerte.index, Arretes_Zones_alerte.values)
    ax.set_title(title)
    fig.savefig("graph_bar.png")
    plt.close(fig)
    #return fig.savefig("static/images/graph_bar.png")


def afficher_carte(Arretes_Zones_alerte, gdf,date):

    """
    Cette fonction va créer la carte du niveau de restriction par département à une date donnée.
    Elle s'applique après une filtration par date. L'aggrégation par département se fait
    dans le corps de la fonction
    """

    #Aggrégation par département
    Arretes_Zones_alerte=Arretes_Zones_alerte.groupby("code_departement").agg({"numero_niveau":max})

    #Ajout de la géographie grâce à géopandas
    
    gdf=pd.merge(gdf, Arretes_Zones_alerte, how="left", left_on="code", right_on="code_departement")
    gdf["numero_niveau"]=gdf["numero_niveau"].fillna(0)
    gdf["niveau_alerte"]=gdf["numero_niveau"].replace([0,1,3,4,5],['0 - Aucun','1 - Vigilance','2 - Alerte','3 - Alerte renforcée','4 - Crise'])

    #Création de la carte
    fig, ax = plt.subplots(figsize=(12,18))

    gdf.plot(ax=ax,
              alpha=.7, 
              edgecolor="black", 
              column="niveau_alerte", 
              legend=True,
              cmap="OrRd")

    ax.set_title("Département par niveau d'alerte sécheresse au {}\n (France métropolitaine uniquement)".format(date), fontsize=16, va='center')
    fig.savefig("carte.png")
    plt.close(fig)
    #return fig.savefig("static/images/carte.png")


def afficher_graph_surface(Arretes_Zones_alerte):


    """
    Cette fonction affiche l'évolution de la surface des eaux superficielles concernées par un arrêté de restriction
    Elle s'applique après une filtration par type d'eau.
    
    """
       
    fig, ax = plt.subplots(figsize=(8,6))

    #production d'une courbe par niveau d'alerte
    for i in Arretes_Zones_alerte["nom_niveau"].unique():

        #Création d'un dataframe temporaire
        X=Arretes_Zones_alerte[Arretes_Zones_alerte["nom_niveau"]==i]

        #On sépare le dataframe en deux en prennant comme dates le début ou la fin de l'arrété
        X1=X[["debut_validite_arrete","surface_zone"]].set_index("debut_validite_arrete")
        X2=X[["fin_validite_arrete","surface_zone"]].set_index("fin_validite_arrete")

        #On assemble les deux dataframes mais en affectant une valeur négative pour les données
        #en fin de validité d'arrété. L'index est trié dans l'ordre chronologique puis nous appliquons
        #une somme cumulée : ainsi lorsqu'un arrêté est pris, les surfaces sont aoutées au stock des surfaces
        #concernées par les arrêtés sécheresse et quand une fin d'arrêté arrive, les surfaces sont soustraites du
        #stock des surfaces concernées
        
        X=pd.concat([X1,-X2], axis=0)
        X=X.sort_index()
        X=X.cumsum()

        #Création du graphique
        X.plot(ax=ax, label="{}".format(i))
        ax.set_xlabel("Année")
        ax.set_ylabel("Surface (km²)")
        ax.grid(visible=True, axis='both')
        ax.set_title("Surfaces des eaux superficielles concernées par un arrêté de restriction au cours du temps")
        ax.set_xlim("2020","2024-05")
    
    ax.legend(Arretes_Zones_alerte["nom_niveau"].unique())
    fig.savefig("graph_surface.png")
    plt.close(fig)
    #return fig.savefig("static/images/graph_surface.png")


def affichage_graph_donnees_par_mois(Arretes_Zones_alerte):  

    """
    Cette fonction va produire la durée moyenne des arrêtés ou la surface moyenne des arrêtés par mois.
    Elle s'applique après une aggrégation par arrêté. 
    """


    Arretes_Zones_alerte=Arretes_Zones_alerte[["debut_validite_arrete",
                                               "surface_zone",
                                               "duree (jours)"]].set_index("debut_validite_arrete")
    Arretes_Zones_alerte["mois"]=Arretes_Zones_alerte.index.to_period("M")  
    
    Arretes_Zones_alerte=Arretes_Zones_alerte.groupby("mois").agg({"duree (jours)":"mean", "surface_zone":"mean"})

    Arretes_Zones_alerte.index=Arretes_Zones_alerte.index.to_timestamp()
    
    fig, ax = plt.subplots(figsize=(8,6))

    ax.stem(Arretes_Zones_alerte.index,Arretes_Zones_alerte["duree (jours)"])
    ax.set_xlabel("Année")
    ax.set_ylabel("Durée (jours)")
    ax.grid(visible=True, axis='both')
    ax.set_title("Durée moyenne des arrêtés de restriction par mois")
    fig.savefig("graph_donnees_mois.png")
    plt.close(fig)
    #return fig.savefig("static/images/graph_donnees_mois.png")
 

##Exploitation

#Récupération de l'URL du fichier geojson pour la création des cartes
URL=dict()
URL["carte_departements"]="https://www.data.gouv.fr/fr/datasets/r/90b9341a-e1f7-4d75-a73c-bbc010c7feeb"

def fonction_exploitation(data,date):
    
    #Chargement des données
    gdf=gpd.read_file(URL["carte_departements"])
    date=pd.to_datetime(date)
    #date pour certains graphs
    
    #bar
    Arretes_Zones_alerte=data
    Arretes_Zones_alerte=filtrage_par_date(Arretes_Zones_alerte,date)
    Arretes_Zones_alerte=agregation_par_niveau_alerte(Arretes_Zones_alerte)
    afficher_graph_bar(Arretes_Zones_alerte, title="Nombre de départements par niveau d'alerte au {}".format(date))
    del Arretes_Zones_alerte

    #carte
    Arretes_Zones_alerte=data
    Arretes_Zones_alerte=filtrage_par_date(Arretes_Zones_alerte,date)
    afficher_carte(Arretes_Zones_alerte,gdf,date)
    del Arretes_Zones_alerte

    #graph surface
    Arretes_Zones_alerte=data
    Arretes_Zones_alerte=filtrage_par_type_eau(Arretes_Zones_alerte,type="SUP")
    afficher_graph_surface(Arretes_Zones_alerte)
    del Arretes_Zones_alerte

    #graph données par mois
    Arretes_Zones_alerte=data
    Arretes_Zones_alerte=agregation_par_arrete(Arretes_Zones_alerte)
    affichage_graph_donnees_par_mois(Arretes_Zones_alerte)
    del Arretes_Zones_alerte

